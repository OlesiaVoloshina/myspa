import React from "react";

import { isMenu, TYPE_CONTAINER_UNORDERED_LIST, TYPE_CONTAINER_ORDERED_LIST, TYPE_CONTAINER_NO_MARKUP, TYPE_CONTAINER_INLINE, isContainer, isContainerItem, initialize, destroy } from "@bloomreach/spa-sdk";

/**
 * The React Context holding the current brXM Component.
 */ const BrComponentContext = React.createContext(undefined);

class BrMeta extends React.Component {
    constructor() {
        super(...arguments);
        this.headRef = React.createRef();
        this.tailRef = React.createRef();
    }
    componentDidMount() {
        this.renderMeta();
    }
    componentDidUpdate(prevProps) {
        prevProps.meta.clear();
        this.renderMeta();
    }
    componentWillUnmount() {
        this.props.meta.clear();
    }
    renderMeta() {
        var _a, _b, _c;
        const head = (_b = (_a = this.headRef) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.nextSibling;
        const tail = (_c = this.tailRef) === null || _c === void 0 ? void 0 : _c.current;
        if (!head || !tail) {
            return;
        }
        this.props.meta.render(head, tail);
    }
    render() {
        return React.createElement(React.Fragment, null, this.props.meta.length > 0 && React.createElement("span", {
            style: {
                display: "none"
            },
            ref: this.headRef
        }), this.props.children, this.props.meta.length > 0 && React.createElement("span", {
            style: {
                display: "none"
            },
            ref: this.tailRef
        }));
    }
}

/**
 * The React Context holding the current brXM Page.
 */ const BrPageContext = React.createContext(undefined);

const BrMappingContext = React.createContext({});

class BrNodeComponent extends React.Component {
    getMapping() {
        return this.props.component.getName();
    }
    fallback() {
        return this.props.children;
    }
    render() {
        const mapping = this.getMapping();
        const component = mapping && this.context[mapping];
        if (!component) {
            return this.fallback();
        }
        return React.createElement(component, this.props);
    }
}

BrNodeComponent.contextType = BrMappingContext;

function BrContainerBox(props) {
    return React.createElement("div", {
        className: props.page.isPreview() ? "hst-container" : undefined
    }, React.Children.map(props.children, child => React.createElement("div", {
        className: props.page.isPreview() ? "hst-container-item" : undefined
    }, child)));
}

function BrContainerInline(props) {
    return React.createElement("div", {
        className: props.page.isPreview() ? "hst-container" : undefined
    }, React.Children.map(props.children, child => React.createElement("span", {
        className: props.page.isPreview() ? "hst-container-item" : undefined
    }, child)));
}

function BrContainerNoMarkup(props) {
    return React.createElement(React.Fragment, null, props.children);
}

function BrContainerOrderedList(props) {
    return React.createElement("ol", {
        className: props.page.isPreview() ? "hst-container" : undefined
    }, React.Children.map(props.children, child => React.createElement("li", {
        className: props.page.isPreview() ? "hst-container-item" : undefined
    }, child)));
}

function BrContainerUnorderedList(props) {
    return React.createElement("ul", {
        className: props.page.isPreview() ? "hst-container" : undefined
    }, React.Children.map(props.children, child => React.createElement("li", {
        className: props.page.isPreview() ? "hst-container-item" : undefined
    }, child)));
}

function BrContainerItemUndefined(props) {
    return React.createElement(React.Fragment, null, 'Component "', props.component.getType(), '" is not defined.');
}

/**
 * The button component that opens for editing a content.
 */ class BrManageContentButton extends React.Component {
    render() {
        var _a;
        if (!((_a = this.context) === null || _a === void 0 ? void 0 : _a.isPreview())) {
            return null;
        }
        return React.createElement(BrMeta, {
            meta: this.props.content.getMeta()
        });
    }
}

BrManageContentButton.contextType = BrPageContext;

/**
 * The button component that opens a menu editor.
 */ class BrManageMenuButton extends React.Component {
    render() {
        var _a;
        if (!((_a = this.context) === null || _a === void 0 ? void 0 : _a.isPreview())) {
            return null;
        }
        const meta = isMenu(this.props.menu) ? this.props.menu.getMeta() : this.props.menu._meta && this.context.getMeta(this.props.menu._meta);
        return meta ? React.createElement(BrMeta, {
            meta
        }) : null;
    }
}

BrManageMenuButton.contextType = BrPageContext;

class BrNodeContainer extends BrNodeComponent {
    getMapping() {
        return this.props.component.getType();
    }
    fallback() {
        switch (this.props.component.getType()) {
          case TYPE_CONTAINER_INLINE:
            return React.createElement(BrContainerInline, Object.assign({}, this.props));

          case TYPE_CONTAINER_NO_MARKUP:
            return React.createElement(BrContainerNoMarkup, Object.assign({}, this.props));

          case TYPE_CONTAINER_ORDERED_LIST:
            return React.createElement(BrContainerOrderedList, Object.assign({}, this.props));

          case TYPE_CONTAINER_UNORDERED_LIST:
            return React.createElement(BrContainerUnorderedList, Object.assign({}, this.props));

          default:
            return React.createElement(BrContainerBox, Object.assign({}, this.props));
        }
    }
}

class BrNodeContainerItem extends BrNodeComponent {
    constructor(props) {
        super(props);
        this.onUpdate = this.onUpdate.bind(this);
    }
    componentDidMount() {
        this.props.component.on("update", this.onUpdate);
    }
    componentDidUpdate(prevProps) {
        if (this.props.component !== prevProps.component) {
            prevProps.component.off("update", this.onUpdate);
            this.props.component.on("update", this.onUpdate);
        }
    }
    componentWillUnmount() {
        this.props.component.off("update", this.onUpdate);
    }
    getMapping() {
        return this.props.component.getType();
    }
    fallback() {
        return React.createElement(BrContainerItemUndefined, Object.assign({}, this.props));
    }
    onUpdate() {
        this.forceUpdate(() => this.props.page.sync());
    }
}

class BrNode extends React.Component {
    renderNode() {
        if (React.Children.count(this.props.children)) {
            return this.props.children;
        }
        const children = this.props.component.getChildren().map((child, index) => React.createElement(BrNode, {
            key: index,
            component: child
        }));
        if (isContainer(this.props.component)) {
            return React.createElement(BrNodeContainer, {
                component: this.props.component,
                page: this.context
            }, children);
        }
        if (isContainerItem(this.props.component)) {
            return React.createElement(BrNodeContainerItem, {
                component: this.props.component,
                page: this.context
            }, children);
        }
        return React.createElement(BrNodeComponent, {
            component: this.props.component,
            page: this.context
        }, children);
    }
    render() {
        return React.createElement(BrComponentContext.Provider, {
            value: this.props.component
        }, React.createElement(BrMeta, {
            meta: this.props.component.getMeta()
        }, this.renderNode()));
    }
}

BrNode.contextType = BrPageContext;

/**
 * The brXM component.
 */ class BrComponent extends React.Component {
    getComponents() {
        if (!this.context) {
            return [];
        }
        if (!this.props.path) {
            return this.context.getChildren();
        }
        const component = this.context.getComponent(...this.props.path.split("/"));
        return component ? [ component ] : [];
    }
    renderComponents() {
        return this.getComponents().map((component, index) => React.createElement(BrNode, {
            key: index,
            component
        }, this.props.children));
    }
    render() {
        return React.createElement(React.Fragment, null, this.renderComponents());
    }
}

BrComponent.contextType = BrComponentContext;

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P((function(resolve) {
            resolve(value);
        }));
    }
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
}

/**
 * @typedef {Object} BrPageProps
 * @property {Configuration} configuration The configuration of the SPA SDK.
 * @property {Object} mapping The brXM and React components mapping.
 * @property {Page | PageModel | undefined} page The pre-initialized page instance or prefetched page model.
 * Mostly this property should be used to transfer state from the server-side to the client-side.
 */
/**
 * The brXM page.
 */ class BrPage extends React.Component {
    /**
     * @param props {BrPageProps}
     */
    constructor(props) {
        super(props);
        this.state = {
            page: props.page && initialize(props.configuration, props.page)
        };
    }
    componentDidMount() {
        var _a;
        if (!this.props.page) {
            this.initialize();
        }
        (_a = this.state.page) === null || _a === void 0 ? void 0 : _a.sync();
    }
    componentDidUpdate(prevProps, prevState) {
        if (this.props.configuration !== prevProps.configuration || this.props.page !== prevProps.page) {
            this.destroy();
            this.initialize(this.props.page === prevProps.page);
        }
        if (this.state.page !== prevState.page) {
            this.forceUpdate(() => {
                var _a;
                return (_a = this.state.page) === null || _a === void 0 ? void 0 : _a.sync();
            });
        }
    }
    componentWillUnmount() {
        this.destroy();
    }
    initialize(force = false) {
        return __awaiter(this, void 0, void 0, (function*() {
            const model = force ? undefined : this.props.page;
            try {
                this.setState({
                    page: model ? initialize(this.props.configuration, model) : yield initialize(this.props.configuration)
                });
            } catch (error) {
                this.setState(() => {
                    throw error;
                });
            }
        }));
    }
    destroy() {
        if (!this.state.page) {
            return;
        }
        destroy(this.state.page);
    }
    render() {
        if (!this.state.page) {
            return null;
        }
        return React.createElement(BrPageContext.Provider, {
            value: this.state.page
        }, React.createElement(BrMappingContext.Provider, {
            value: this.props.mapping
        }, React.createElement(BrNode, {
            component: this.state.page.getComponent()
        }, this.props.children)));
    }
}

export { BrComponent, BrComponentContext, BrManageContentButton, BrManageMenuButton, BrPage, BrPageContext };
