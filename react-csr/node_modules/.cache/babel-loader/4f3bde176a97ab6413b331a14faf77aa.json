{"ast":null,"code":"'use strict';\n\nconst anyMap = new WeakMap();\nconst eventsMap = new WeakMap();\nconst producersMap = new WeakMap();\nconst anyProducer = Symbol('anyProducer');\nconst resolvedPromise = Promise.resolve();\nconst listenerAdded = Symbol('listenerAdded');\nconst listenerRemoved = Symbol('listenerRemoved');\n\nfunction assertEventName(eventName) {\n  if (typeof eventName !== 'string' && typeof eventName !== 'symbol') {\n    throw new TypeError('eventName must be a string or a symbol');\n  }\n}\n\nfunction assertListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('listener must be a function');\n  }\n}\n\nfunction getListeners(instance, eventName) {\n  const events = eventsMap.get(instance);\n\n  if (!events.has(eventName)) {\n    events.set(eventName, new Set());\n  }\n\n  return events.get(eventName);\n}\n\nfunction getEventProducers(instance, eventName) {\n  const key = typeof eventName === 'string' || typeof eventName === 'symbol' ? eventName : anyProducer;\n  const producers = producersMap.get(instance);\n\n  if (!producers.has(key)) {\n    producers.set(key, new Set());\n  }\n\n  return producers.get(key);\n}\n\nfunction enqueueProducers(instance, eventName, eventData) {\n  const producers = producersMap.get(instance);\n\n  if (producers.has(eventName)) {\n    for (const producer of producers.get(eventName)) {\n      producer.enqueue(eventData);\n    }\n  }\n\n  if (producers.has(anyProducer)) {\n    const item = Promise.all([eventName, eventData]);\n\n    for (const producer of producers.get(anyProducer)) {\n      producer.enqueue(item);\n    }\n  }\n}\n\nfunction iterator(instance, eventNames) {\n  eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n  let isFinished = false;\n\n  let flush = () => {};\n\n  let queue = [];\n  const producer = {\n    enqueue(item) {\n      queue.push(item);\n      flush();\n    },\n\n    finish() {\n      isFinished = true;\n      flush();\n    }\n\n  };\n\n  for (const eventName of eventNames) {\n    getEventProducers(instance, eventName).add(producer);\n  }\n\n  return {\n    async next() {\n      if (!queue) {\n        return {\n          done: true\n        };\n      }\n\n      if (queue.length === 0) {\n        if (isFinished) {\n          queue = undefined;\n          return this.next();\n        }\n\n        await new Promise(resolve => {\n          flush = resolve;\n        });\n        return this.next();\n      }\n\n      return {\n        done: false,\n        value: await queue.shift()\n      };\n    },\n\n    async return(value) {\n      queue = undefined;\n\n      for (const eventName of eventNames) {\n        getEventProducers(instance, eventName).delete(producer);\n      }\n\n      flush();\n      return arguments.length > 0 ? {\n        done: true,\n        value: await value\n      } : {\n        done: true\n      };\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n\n  };\n}\n\nfunction defaultMethodNamesOrAssert(methodNames) {\n  if (methodNames === undefined) {\n    return allEmitteryMethods;\n  }\n\n  if (!Array.isArray(methodNames)) {\n    throw new TypeError('`methodNames` must be an array of strings');\n  }\n\n  for (const methodName of methodNames) {\n    if (!allEmitteryMethods.includes(methodName)) {\n      if (typeof methodName !== 'string') {\n        throw new TypeError('`methodNames` element must be a string');\n      }\n\n      throw new Error(`${methodName} is not Emittery method`);\n    }\n  }\n\n  return methodNames;\n}\n\nconst isListenerSymbol = symbol => symbol === listenerAdded || symbol === listenerRemoved;\n\nclass Emittery {\n  static mixin(emitteryPropertyName, methodNames) {\n    methodNames = defaultMethodNamesOrAssert(methodNames);\n    return target => {\n      if (typeof target !== 'function') {\n        throw new TypeError('`target` must be function');\n      }\n\n      for (const methodName of methodNames) {\n        if (target.prototype[methodName] !== undefined) {\n          throw new Error(`The property \\`${methodName}\\` already exists on \\`target\\``);\n        }\n      }\n\n      function getEmitteryProperty() {\n        Object.defineProperty(this, emitteryPropertyName, {\n          enumerable: false,\n          value: new Emittery()\n        });\n        return this[emitteryPropertyName];\n      }\n\n      Object.defineProperty(target.prototype, emitteryPropertyName, {\n        enumerable: false,\n        get: getEmitteryProperty\n      });\n\n      const emitteryMethodCaller = methodName => function (...args) {\n        return this[emitteryPropertyName][methodName](...args);\n      };\n\n      for (const methodName of methodNames) {\n        Object.defineProperty(target.prototype, methodName, {\n          enumerable: false,\n          value: emitteryMethodCaller(methodName)\n        });\n      }\n\n      return target;\n    };\n  }\n\n  constructor() {\n    anyMap.set(this, new Set());\n    eventsMap.set(this, new Map());\n    producersMap.set(this, new Map());\n  }\n\n  on(eventNames, listener) {\n    assertListener(listener);\n    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\n    for (const eventName of eventNames) {\n      assertEventName(eventName);\n      getListeners(this, eventName).add(listener);\n\n      if (!isListenerSymbol(eventName)) {\n        this.emit(listenerAdded, {\n          eventName,\n          listener\n        });\n      }\n    }\n\n    return this.off.bind(this, eventNames, listener);\n  }\n\n  off(eventNames, listener) {\n    assertListener(listener);\n    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\n    for (const eventName of eventNames) {\n      assertEventName(eventName);\n      getListeners(this, eventName).delete(listener);\n\n      if (!isListenerSymbol(eventName)) {\n        this.emit(listenerRemoved, {\n          eventName,\n          listener\n        });\n      }\n    }\n  }\n\n  once(eventNames) {\n    return new Promise(resolve => {\n      const off = this.on(eventNames, data => {\n        off();\n        resolve(data);\n      });\n    });\n  }\n\n  events(eventNames) {\n    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\n    for (const eventName of eventNames) {\n      assertEventName(eventName);\n    }\n\n    return iterator(this, eventNames);\n  }\n\n  async emit(eventName, eventData) {\n    assertEventName(eventName);\n    enqueueProducers(this, eventName, eventData);\n    const listeners = getListeners(this, eventName);\n    const anyListeners = anyMap.get(this);\n    const staticListeners = [...listeners];\n    const staticAnyListeners = isListenerSymbol(eventName) ? [] : [...anyListeners];\n    await resolvedPromise;\n    await Promise.all([...staticListeners.map(async listener => {\n      if (listeners.has(listener)) {\n        return listener(eventData);\n      }\n    }), ...staticAnyListeners.map(async listener => {\n      if (anyListeners.has(listener)) {\n        return listener(eventName, eventData);\n      }\n    })]);\n  }\n\n  async emitSerial(eventName, eventData) {\n    assertEventName(eventName);\n    const listeners = getListeners(this, eventName);\n    const anyListeners = anyMap.get(this);\n    const staticListeners = [...listeners];\n    const staticAnyListeners = [...anyListeners];\n    await resolvedPromise;\n    /* eslint-disable no-await-in-loop */\n\n    for (const listener of staticListeners) {\n      if (listeners.has(listener)) {\n        await listener(eventData);\n      }\n    }\n\n    for (const listener of staticAnyListeners) {\n      if (anyListeners.has(listener)) {\n        await listener(eventName, eventData);\n      }\n    }\n    /* eslint-enable no-await-in-loop */\n\n  }\n\n  onAny(listener) {\n    assertListener(listener);\n    anyMap.get(this).add(listener);\n    this.emit(listenerAdded, {\n      listener\n    });\n    return this.offAny.bind(this, listener);\n  }\n\n  anyEvent() {\n    return iterator(this);\n  }\n\n  offAny(listener) {\n    assertListener(listener);\n    this.emit(listenerRemoved, {\n      listener\n    });\n    anyMap.get(this).delete(listener);\n  }\n\n  clearListeners(eventNames) {\n    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\n    for (const eventName of eventNames) {\n      if (typeof eventName === 'string' || typeof eventName === 'symbol') {\n        getListeners(this, eventName).clear();\n        const producers = getEventProducers(this, eventName);\n\n        for (const producer of producers) {\n          producer.finish();\n        }\n\n        producers.clear();\n      } else {\n        anyMap.get(this).clear();\n\n        for (const listeners of eventsMap.get(this).values()) {\n          listeners.clear();\n        }\n\n        for (const producers of producersMap.get(this).values()) {\n          for (const producer of producers) {\n            producer.finish();\n          }\n\n          producers.clear();\n        }\n      }\n    }\n  }\n\n  listenerCount(eventNames) {\n    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n    let count = 0;\n\n    for (const eventName of eventNames) {\n      if (typeof eventName === 'string') {\n        count += anyMap.get(this).size + getListeners(this, eventName).size + getEventProducers(this, eventName).size + getEventProducers(this).size;\n        continue;\n      }\n\n      if (typeof eventName !== 'undefined') {\n        assertEventName(eventName);\n      }\n\n      count += anyMap.get(this).size;\n\n      for (const value of eventsMap.get(this).values()) {\n        count += value.size;\n      }\n\n      for (const value of producersMap.get(this).values()) {\n        count += value.size;\n      }\n    }\n\n    return count;\n  }\n\n  bindMethods(target, methodNames) {\n    if (typeof target !== 'object' || target === null) {\n      throw new TypeError('`target` must be an object');\n    }\n\n    methodNames = defaultMethodNamesOrAssert(methodNames);\n\n    for (const methodName of methodNames) {\n      if (target[methodName] !== undefined) {\n        throw new Error(`The property \\`${methodName}\\` already exists on \\`target\\``);\n      }\n\n      Object.defineProperty(target, methodName, {\n        enumerable: false,\n        value: this[methodName].bind(this)\n      });\n    }\n  }\n\n}\n\nconst allEmitteryMethods = Object.getOwnPropertyNames(Emittery.prototype).filter(v => v !== 'constructor'); // Subclass used to encourage TS users to type their events.\n\nEmittery.Typed = class extends Emittery {};\nObject.defineProperty(Emittery.Typed, 'Typed', {\n  enumerable: false,\n  value: undefined\n});\nObject.defineProperty(Emittery, 'listenerAdded', {\n  value: listenerAdded,\n  writable: false,\n  enumerable: true,\n  configurable: false\n});\nObject.defineProperty(Emittery, 'listenerRemoved', {\n  value: listenerRemoved,\n  writable: false,\n  enumerable: true,\n  configurable: false\n});\nmodule.exports = Emittery;","map":{"version":3,"sources":["C:/Projects/bloomreach/spa/react-csr/node_modules/emittery/index.js"],"names":["anyMap","WeakMap","eventsMap","producersMap","anyProducer","Symbol","resolvedPromise","Promise","resolve","listenerAdded","listenerRemoved","assertEventName","eventName","TypeError","assertListener","listener","getListeners","instance","events","get","has","set","Set","getEventProducers","key","producers","enqueueProducers","eventData","producer","enqueue","item","all","iterator","eventNames","Array","isArray","isFinished","flush","queue","push","finish","add","next","done","length","undefined","value","shift","return","delete","arguments","asyncIterator","defaultMethodNamesOrAssert","methodNames","allEmitteryMethods","methodName","includes","Error","isListenerSymbol","symbol","Emittery","mixin","emitteryPropertyName","target","prototype","getEmitteryProperty","Object","defineProperty","enumerable","emitteryMethodCaller","args","constructor","Map","on","emit","off","bind","once","data","listeners","anyListeners","staticListeners","staticAnyListeners","map","emitSerial","onAny","offAny","anyEvent","clearListeners","clear","values","listenerCount","count","size","bindMethods","getOwnPropertyNames","filter","v","Typed","writable","configurable","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst anyMap = new WeakMap();\nconst eventsMap = new WeakMap();\nconst producersMap = new WeakMap();\nconst anyProducer = Symbol('anyProducer');\nconst resolvedPromise = Promise.resolve();\n\nconst listenerAdded = Symbol('listenerAdded');\nconst listenerRemoved = Symbol('listenerRemoved');\n\nfunction assertEventName(eventName) {\n\tif (typeof eventName !== 'string' && typeof eventName !== 'symbol') {\n\t\tthrow new TypeError('eventName must be a string or a symbol');\n\t}\n}\n\nfunction assertListener(listener) {\n\tif (typeof listener !== 'function') {\n\t\tthrow new TypeError('listener must be a function');\n\t}\n}\n\nfunction getListeners(instance, eventName) {\n\tconst events = eventsMap.get(instance);\n\tif (!events.has(eventName)) {\n\t\tevents.set(eventName, new Set());\n\t}\n\n\treturn events.get(eventName);\n}\n\nfunction getEventProducers(instance, eventName) {\n\tconst key = typeof eventName === 'string' || typeof eventName === 'symbol' ? eventName : anyProducer;\n\tconst producers = producersMap.get(instance);\n\tif (!producers.has(key)) {\n\t\tproducers.set(key, new Set());\n\t}\n\n\treturn producers.get(key);\n}\n\nfunction enqueueProducers(instance, eventName, eventData) {\n\tconst producers = producersMap.get(instance);\n\tif (producers.has(eventName)) {\n\t\tfor (const producer of producers.get(eventName)) {\n\t\t\tproducer.enqueue(eventData);\n\t\t}\n\t}\n\n\tif (producers.has(anyProducer)) {\n\t\tconst item = Promise.all([eventName, eventData]);\n\t\tfor (const producer of producers.get(anyProducer)) {\n\t\t\tproducer.enqueue(item);\n\t\t}\n\t}\n}\n\nfunction iterator(instance, eventNames) {\n\teventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\n\tlet isFinished = false;\n\tlet flush = () => {};\n\tlet queue = [];\n\n\tconst producer = {\n\t\tenqueue(item) {\n\t\t\tqueue.push(item);\n\t\t\tflush();\n\t\t},\n\t\tfinish() {\n\t\t\tisFinished = true;\n\t\t\tflush();\n\t\t}\n\t};\n\n\tfor (const eventName of eventNames) {\n\t\tgetEventProducers(instance, eventName).add(producer);\n\t}\n\n\treturn {\n\t\tasync next() {\n\t\t\tif (!queue) {\n\t\t\t\treturn {done: true};\n\t\t\t}\n\n\t\t\tif (queue.length === 0) {\n\t\t\t\tif (isFinished) {\n\t\t\t\t\tqueue = undefined;\n\t\t\t\t\treturn this.next();\n\t\t\t\t}\n\n\t\t\t\tawait new Promise(resolve => {\n\t\t\t\t\tflush = resolve;\n\t\t\t\t});\n\n\t\t\t\treturn this.next();\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdone: false,\n\t\t\t\tvalue: await queue.shift()\n\t\t\t};\n\t\t},\n\n\t\tasync return(value) {\n\t\t\tqueue = undefined;\n\n\t\t\tfor (const eventName of eventNames) {\n\t\t\t\tgetEventProducers(instance, eventName).delete(producer);\n\t\t\t}\n\n\t\t\tflush();\n\n\t\t\treturn arguments.length > 0 ?\n\t\t\t\t{done: true, value: await value} :\n\t\t\t\t{done: true};\n\t\t},\n\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn this;\n\t\t}\n\t};\n}\n\nfunction defaultMethodNamesOrAssert(methodNames) {\n\tif (methodNames === undefined) {\n\t\treturn allEmitteryMethods;\n\t}\n\n\tif (!Array.isArray(methodNames)) {\n\t\tthrow new TypeError('`methodNames` must be an array of strings');\n\t}\n\n\tfor (const methodName of methodNames) {\n\t\tif (!allEmitteryMethods.includes(methodName)) {\n\t\t\tif (typeof methodName !== 'string') {\n\t\t\t\tthrow new TypeError('`methodNames` element must be a string');\n\t\t\t}\n\n\t\t\tthrow new Error(`${methodName} is not Emittery method`);\n\t\t}\n\t}\n\n\treturn methodNames;\n}\n\nconst isListenerSymbol = symbol => symbol === listenerAdded || symbol === listenerRemoved;\n\nclass Emittery {\n\tstatic mixin(emitteryPropertyName, methodNames) {\n\t\tmethodNames = defaultMethodNamesOrAssert(methodNames);\n\t\treturn target => {\n\t\t\tif (typeof target !== 'function') {\n\t\t\t\tthrow new TypeError('`target` must be function');\n\t\t\t}\n\n\t\t\tfor (const methodName of methodNames) {\n\t\t\t\tif (target.prototype[methodName] !== undefined) {\n\t\t\t\t\tthrow new Error(`The property \\`${methodName}\\` already exists on \\`target\\``);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction getEmitteryProperty() {\n\t\t\t\tObject.defineProperty(this, emitteryPropertyName, {\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\tvalue: new Emittery()\n\t\t\t\t});\n\t\t\t\treturn this[emitteryPropertyName];\n\t\t\t}\n\n\t\t\tObject.defineProperty(target.prototype, emitteryPropertyName, {\n\t\t\t\tenumerable: false,\n\t\t\t\tget: getEmitteryProperty\n\t\t\t});\n\n\t\t\tconst emitteryMethodCaller = methodName => function (...args) {\n\t\t\t\treturn this[emitteryPropertyName][methodName](...args);\n\t\t\t};\n\n\t\t\tfor (const methodName of methodNames) {\n\t\t\t\tObject.defineProperty(target.prototype, methodName, {\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\tvalue: emitteryMethodCaller(methodName)\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn target;\n\t\t};\n\t}\n\n\tconstructor() {\n\t\tanyMap.set(this, new Set());\n\t\teventsMap.set(this, new Map());\n\t\tproducersMap.set(this, new Map());\n\t}\n\n\ton(eventNames, listener) {\n\t\tassertListener(listener);\n\n\t\teventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\t\tfor (const eventName of eventNames) {\n\t\t\tassertEventName(eventName);\n\t\t\tgetListeners(this, eventName).add(listener);\n\n\t\t\tif (!isListenerSymbol(eventName)) {\n\t\t\t\tthis.emit(listenerAdded, {eventName, listener});\n\t\t\t}\n\t\t}\n\n\t\treturn this.off.bind(this, eventNames, listener);\n\t}\n\n\toff(eventNames, listener) {\n\t\tassertListener(listener);\n\n\t\teventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\t\tfor (const eventName of eventNames) {\n\t\t\tassertEventName(eventName);\n\t\t\tgetListeners(this, eventName).delete(listener);\n\n\t\t\tif (!isListenerSymbol(eventName)) {\n\t\t\t\tthis.emit(listenerRemoved, {eventName, listener});\n\t\t\t}\n\t\t}\n\t}\n\n\tonce(eventNames) {\n\t\treturn new Promise(resolve => {\n\t\t\tconst off = this.on(eventNames, data => {\n\t\t\t\toff();\n\t\t\t\tresolve(data);\n\t\t\t});\n\t\t});\n\t}\n\n\tevents(eventNames) {\n\t\teventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\t\tfor (const eventName of eventNames) {\n\t\t\tassertEventName(eventName);\n\t\t}\n\n\t\treturn iterator(this, eventNames);\n\t}\n\n\tasync emit(eventName, eventData) {\n\t\tassertEventName(eventName);\n\n\t\tenqueueProducers(this, eventName, eventData);\n\n\t\tconst listeners = getListeners(this, eventName);\n\t\tconst anyListeners = anyMap.get(this);\n\t\tconst staticListeners = [...listeners];\n\t\tconst staticAnyListeners = isListenerSymbol(eventName) ? [] : [...anyListeners];\n\n\t\tawait resolvedPromise;\n\t\tawait Promise.all([\n\t\t\t...staticListeners.map(async listener => {\n\t\t\t\tif (listeners.has(listener)) {\n\t\t\t\t\treturn listener(eventData);\n\t\t\t\t}\n\t\t\t}),\n\t\t\t...staticAnyListeners.map(async listener => {\n\t\t\t\tif (anyListeners.has(listener)) {\n\t\t\t\t\treturn listener(eventName, eventData);\n\t\t\t\t}\n\t\t\t})\n\t\t]);\n\t}\n\n\tasync emitSerial(eventName, eventData) {\n\t\tassertEventName(eventName);\n\n\t\tconst listeners = getListeners(this, eventName);\n\t\tconst anyListeners = anyMap.get(this);\n\t\tconst staticListeners = [...listeners];\n\t\tconst staticAnyListeners = [...anyListeners];\n\n\t\tawait resolvedPromise;\n\t\t/* eslint-disable no-await-in-loop */\n\t\tfor (const listener of staticListeners) {\n\t\t\tif (listeners.has(listener)) {\n\t\t\t\tawait listener(eventData);\n\t\t\t}\n\t\t}\n\n\t\tfor (const listener of staticAnyListeners) {\n\t\t\tif (anyListeners.has(listener)) {\n\t\t\t\tawait listener(eventName, eventData);\n\t\t\t}\n\t\t}\n\t\t/* eslint-enable no-await-in-loop */\n\t}\n\n\tonAny(listener) {\n\t\tassertListener(listener);\n\t\tanyMap.get(this).add(listener);\n\t\tthis.emit(listenerAdded, {listener});\n\t\treturn this.offAny.bind(this, listener);\n\t}\n\n\tanyEvent() {\n\t\treturn iterator(this);\n\t}\n\n\toffAny(listener) {\n\t\tassertListener(listener);\n\t\tthis.emit(listenerRemoved, {listener});\n\t\tanyMap.get(this).delete(listener);\n\t}\n\n\tclearListeners(eventNames) {\n\t\teventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\n\t\tfor (const eventName of eventNames) {\n\t\t\tif (typeof eventName === 'string' || typeof eventName === 'symbol') {\n\t\t\t\tgetListeners(this, eventName).clear();\n\n\t\t\t\tconst producers = getEventProducers(this, eventName);\n\n\t\t\t\tfor (const producer of producers) {\n\t\t\t\t\tproducer.finish();\n\t\t\t\t}\n\n\t\t\t\tproducers.clear();\n\t\t\t} else {\n\t\t\t\tanyMap.get(this).clear();\n\n\t\t\t\tfor (const listeners of eventsMap.get(this).values()) {\n\t\t\t\t\tlisteners.clear();\n\t\t\t\t}\n\n\t\t\t\tfor (const producers of producersMap.get(this).values()) {\n\t\t\t\t\tfor (const producer of producers) {\n\t\t\t\t\t\tproducer.finish();\n\t\t\t\t\t}\n\n\t\t\t\t\tproducers.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlistenerCount(eventNames) {\n\t\teventNames = Array.isArray(eventNames) ? eventNames : [eventNames];\n\t\tlet count = 0;\n\n\t\tfor (const eventName of eventNames) {\n\t\t\tif (typeof eventName === 'string') {\n\t\t\t\tcount += anyMap.get(this).size + getListeners(this, eventName).size +\n\t\t\t\t\tgetEventProducers(this, eventName).size + getEventProducers(this).size;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (typeof eventName !== 'undefined') {\n\t\t\t\tassertEventName(eventName);\n\t\t\t}\n\n\t\t\tcount += anyMap.get(this).size;\n\n\t\t\tfor (const value of eventsMap.get(this).values()) {\n\t\t\t\tcount += value.size;\n\t\t\t}\n\n\t\t\tfor (const value of producersMap.get(this).values()) {\n\t\t\t\tcount += value.size;\n\t\t\t}\n\t\t}\n\n\t\treturn count;\n\t}\n\n\tbindMethods(target, methodNames) {\n\t\tif (typeof target !== 'object' || target === null) {\n\t\t\tthrow new TypeError('`target` must be an object');\n\t\t}\n\n\t\tmethodNames = defaultMethodNamesOrAssert(methodNames);\n\n\t\tfor (const methodName of methodNames) {\n\t\t\tif (target[methodName] !== undefined) {\n\t\t\t\tthrow new Error(`The property \\`${methodName}\\` already exists on \\`target\\``);\n\t\t\t}\n\n\t\t\tObject.defineProperty(target, methodName, {\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: this[methodName].bind(this)\n\t\t\t});\n\t\t}\n\t}\n}\n\nconst allEmitteryMethods = Object.getOwnPropertyNames(Emittery.prototype).filter(v => v !== 'constructor');\n\n// Subclass used to encourage TS users to type their events.\nEmittery.Typed = class extends Emittery {};\nObject.defineProperty(Emittery.Typed, 'Typed', {\n\tenumerable: false,\n\tvalue: undefined\n});\n\nObject.defineProperty(Emittery, 'listenerAdded', {\n\tvalue: listenerAdded,\n\twritable: false,\n\tenumerable: true,\n\tconfigurable: false\n});\nObject.defineProperty(Emittery, 'listenerRemoved', {\n\tvalue: listenerRemoved,\n\twritable: false,\n\tenumerable: true,\n\tconfigurable: false\n});\n\nmodule.exports = Emittery;\n"]},"metadata":{},"sourceType":"script"}